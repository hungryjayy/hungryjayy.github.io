# 가상 메모리



![img](https://upload.wikimedia.org/wikipedia/commons/thumb/6/6e/Virtual_memory.svg/220px-Virtual_memory.svg.png) 

: 프로세스에 필요한 메모리 전체가 물리 메모리에 적재되지 않고도 실행할 수 있도록, **물리 메모리**를 **가상의 엄청나게 큰 메모리(가상 메모리)** 로 추상화해서 사용하는 기법

* 원래는 물리 메모리에 필요한 모든 것을 적재했었음 -> 실행할 프로그램에 필요한 메모리가 실제 물리 메모리보다 크다면 실행이 불가하다는 문제
* 필요한 페이지만 **메모리**에, 나머지는 **디스크**(보조기억장치)에 저장하고, 논리 **페이지**를 물리 메모리의 **프레임**에 사상해주는 것은 **MMU**의 역할
* **논리 메모리와 물리 메모리 개념을 분리**
  * **가상 주소 공간**을 제공함으로써 개발자는 물리 메모리를 신경쓰지 않고 **가상 메모리만을 신경 쓰면 됨**

<br>

#### 또다른 장점: 프로세스 간 페이지 공유

* 각 물리 메모리 페이지들은 모든 프로세스에 공유되고 있음.

<br>

### 가상 주소 공간

* 한 프로세스가 메모리에 **실제로 저장되는 논리적인 모습을 구현한다.**
* **가상 주소**는 **MMU**(Memory Management Unit)에 의해 **물리 주소**로 사상(Mapping)된다.
* e.g) 한 프로그램이 실행되며 논리 메모리로 100KB 가 요구되었다고 할 때, 실행까지에 필요한 메모리 공간`(Heap영역, Stack 영역, 코드, 데이터)`의 합이 40KB 라면, 실제 물리 메모리에는 40KB 만 올라가 있고, 나머지 60KB 만큼은 필요시에 물리메모리에 요구함.

<br>

## 요구 페이징(demand paging)

* 프로그램 전체를 디스크에서 메모리에 적재하지 않고 초기에 필요한 것만 적재

* 한번도 접근되지 않은 페이지는 물리 메모리에 적재되지 않음.

* 프로세스 내 개별 페이지들은 페이저에 의해 관리됨.

* 만약 프로세스 중 물리메모리에 올라와있지 않은 페이지가 요구되면, **page fault**(페이지 부재)

  * **실제로는 참조 지역성 덕분에 페이지 부재가 잦지는 않다고 함.**

<br>

*참조 지역성: 시간 지역성(최근에 참조된 건 곧 다시 참조될 확률 높음), 공간 지역성(참조된 주소와 인접한 주소가 다시 참조될 확률 높음)*

<br>

## page fault

1. 실행되는 Process에서 필요한 프레임(페이지)를 가져오기 위해 Page Table을 봤는데, `i(invalid)`로 되어있으면, **OS**에게 페이지를 찾아올 것을 요청
2. OS가 디스크에서 필요한 페이지의 위치 찾음
3. 빈 페이지 프레임을 찾는다. 그러나, 빈 프레임이 없다면?
   1. **페이지 교체 알고리즘**을 통해 내려갈(swap out) victim 페이지를 고른다.
   2. 해당 페이지를 디스크에 기록하고, 관련 페이지 테이블을 수정한다.
      * 이 때 victim 프레임 swap out, 페이지 swap in 하는 두번의 디스크 접근이라 오버헤드일 수 있어, 줄여야함.
        1. 모든 페이지마다 변경 bit를 주고, 확인해서 변경된건 어차피 disk에 적용해야하기 때문에 선택
        2. **다른 페이지 교체 알고리즘**
4. 새롭게 비워진(혹은 원래 있던) 페이지 테이블 내 프레임에 새 페이지를 읽어오고, 프레임 테이블을 수정한다.
5. 사용자 프로세스 재시작

<Br>

* *페이지 테이블과 요구 페이징*

<img src="https://media.vlpt.us/images/gimtommang11/post/2d82d84f-9878-4da4-b564-c78d9f47f838/demend_paging.png" alt="img" style="zoom: 67%;" /> 

* 출처: https://velog.io/@gimtommang11/%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC

<img src="https://media.vlpt.us/images/gimtommang11/post/e517d830-bfb9-401e-98b5-2321fb0489ef/page_fault_process.png" alt="img" style="zoom:67%;" /> 

* 출처: https://velog.io/@gimtommang11/%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC
* MMU가 OS에게 제어권을 넘겨 Disk(보조기억장치)에서 가져오는 과정

<br>

### 페이지 교체 알고리즘

1. **FIFO** : 가장 오래된것 내리기

   * 이해하기 쉬우나, **오래된 페이지가 항상 필요하지 않다는 것을 보장할 수 없으며** 효율이 좋지 않음
   * **Belady의 모순**: 물리메모리에 페이지를 저장할 수 있는 프레임 갯수를 늘리면 page fault가 줄을 것이라 생각했지만, 오히려 page fault가 많아지는 것
     * 오래되어서 디스크로 내렸는데 사실은 그 페이지가 앞으로 많이 사용될 페이지인 경우. 따라서 항상 그런것은 아니다.

   

2. **OPR**(최적 페이지 교체): **앞으로 가장 오랫동안 사용되지 않을** 페이지 내리기

   * 가장 효율이 좋으나, 실제에서는 불가능함. 보통 연구 목적으로 사용한다고 함.
   * Belady의 모순을 해결

   

3. **LRU**: 가장 오랫동안 참조(사용)되지 않은 페이지 내리기

   * FIFO보단 좋고, OPR보단 좋지 않다고 함.
   * 지역성이라는 개념이 있어, 실제로는 이게 적합하다고 함
   * Belady 모순 없음

   

4. LFU: 가장 적게 사용된 페이지 내리기

   * 특정 페이지가 초반에만 집중적으로 사용되었으면, 이제 더 이상 사용되지 않더라도 계속 메모리에 머물게 되는 문제.
   * 잘 쓰이지 않음

<br><br>

#### Reference)

#### https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS

#### https://velog.io/@gimtommang11/%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC

#### https://frontalnh.github.io/2018/04/04/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/