# 가상 메모리

: 프로세스에 필요한 메모리 전체가 물리 메모리에 적재되지 않고도 실행할 수 있도록, **물리 메모리**를 **가상의 엄청나게 큰 메모리(가상 메모리)**로 추상화해서 사용하는 기법

* 원래는 물리 메모리에 필요한 모든 것을 적재했었음
  * 실행할 프로그램에 필요한 메모리가 실제 물리 메모리보다 크다면 실행이 불가하다는 문제
* 필요한 페이지만 메모리에, 나머지는 디스크(보조기억장치)에 저장하고, 논리 **페이지**를 물리 메모리의 **프레임**에 사상해주는 것은 **MMU**의 역할
* **논리 메모리와 물리 메모리 개념을 분리**
  * **가상 주소 공간**을 제공함으로써 개발자는 물리 메모리를 신경쓰지 않고 **가상 메모리만을 신경 쓰면 됨**



#### 또다른 장점: 프로세스 간 페이지 공유

* 각 물리 메모리 페이지들은 모든 프로세스에 공유되고 있음.
* `fork()`와 같은 것들로 프로세스를 생성하면 페이지들이 공유됨



### 가상 주소 공간

* 한 프로세스가 메모리에 실제로 저장되는 **논리적인 모습을 구현한 공간**
* e.g) 한 프로그램이 실행되며 논리 메모리로 100KB 가 요구되었다고 할 때, 실행까지에 필요한 메모리 공간`(Heap영역, Stack 영역, 코드, 데이터)`의 합이 40KB 라면, 실제 물리 메모리에는 40KB 만 올라가 있고, 나머지 60KB 만큼은 필요시에 물리메모리에 요구함.



## 요구 페이징(demand paging)

* 프로그램 전체를 디스크에서 메모리에 적재하지 않고 초기에 필요한 것만 적재

* 한번도 접근되지 않은 페이지는 물리 메모리에 적재되지 않음.

* 프로세스 내 개별 페이지들은 페이저에 의해 관리됨.

* 만약 프로세스 중 물리메모리에 올라와있지 않은 페이지가 요구되면, **page fault**(페이지 부재)

  * 실제로는 **참조 지역성** 덕분에 페이지 부재가 잦지는 않다고 함.

    *참조 지역성: 시간 지역성(최근에 참조된 건 곧 다시 참조될 확률 높음), 공간 지역성(참조된 주소와 인접한 주소가 다시 참조될 확률 높음)*



## page fault

1. 디스크에서 필요한 페이지의 위치 찾음
2. 빈 페이지 프레임을 찾는다. 그러나, 빈 프레임이 없다면?
   1. **페이지 교체 알고리즘**을 통해 내려갈(swap out) victim 페이지를 고른다.
   2. 해당 페이지를 디스크에 기록하고, 관련 페이지 테이블을 수정한다.
      * 이 때 victim 프레임 swap out, 페이지 swap in 하는 두번의 디스크 접근이라 오버헤드일 수 있어, 줄여야함.
        1. 모든 페이지마다 변경 bit를 주고, 확인해서 변경된건 어차피 disk에 적용해야하기 때문에 선택
        2. **다른 페이지 교체 알고리즘**
3. 새롭게 비워진(혹은 원래 있던) 페이지 테이블 내 프레임에 새 페이지를 읽어오고, 프레임 테이블을 수정한다.
4. 사용자 프로세스 재시작



* *페이지 테이블과 요구 페이징*

<img src="https://media.vlpt.us/images/gimtommang11/post/2d82d84f-9878-4da4-b564-c78d9f47f838/demend_paging.png" alt="img" style="zoom: 67%;" /> 

* 출처: https://velog.io/@gimtommang11/%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC

<img src="https://media.vlpt.us/images/gimtommang11/post/e517d830-bfb9-401e-98b5-2321fb0489ef/page_fault_process.png" alt="img" style="zoom:67%;" /> 

* 출처: https://velog.io/@gimtommang11/%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC
* MMU가 OS에게 제어권을 넘겨 Disk(보조기억장치)에서 가져오는 과정



### 페이지 교체 알고리즘

1. **FIFO** : 가장 오래된것 내리기

   * 이해하기 쉬우나, 오래된 페이지가 항상 필요하지 않다는 것을 보장할 수 없으며 효율이 좋지 않음
   * Belady의 모순: 페이지를 저장할 수 있는 프레임 갯수를 늘리면 page fault가 줄을 것이라 생각했지만, 오히려 page fault가 많아지는 것.(항상 그런것은 아니지만, 저런한 경우가 존재)

   

2. **OPR**(최적 페이지 교체): **앞으로 가장 오랫동안 사용되지 않을** 페이지 내리기

   * 가장 효율이 좋으나, 구현이 일단 어려움
   * Belady의 모순을 해결

   

3. **LRU**: 가장 오랫동안 참조(사용)되지 않은 페이지 내리기

   * FIFO보단 좋고, OPR보단 좋지 않다고 함.

   

4. LFU: 가장 적게 사용된 페이지 내리기

   * 특정 페이지가 초반에만 집중적으로 사용되었으면, 이제 더 이상 사용되지 않더라도 계속 메모리에 머물게 되는 문제.
   * 잘 쓰이지 않음



#### Reference)

#### https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS

#### https://velog.io/@gimtommang11/%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC

#### https://frontalnh.github.io/2018/04/04/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/