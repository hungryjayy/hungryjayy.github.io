<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://hungryjayy.github.io/</id><title>hungryjayy</title><subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2025-10-24T19:16:19+09:00</updated> <author> <name>Joowon Son</name> <uri>https://hungryjayy.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://hungryjayy.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://hungryjayy.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2025 Joowon Son </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Ktlint 도입하기</title><link href="https://hungryjayy.github.io/posts/Ktlint_%EB%8F%84%EC%9E%85%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="Ktlint 도입하기" /><published>2025-10-24T00:00:00+09:00</published> <updated>2025-10-24T00:00:00+09:00</updated> <id>https://hungryjayy.github.io/posts/Ktlint_%EB%8F%84%EC%9E%85%ED%95%98%EA%B8%B0/</id> <content src="https://hungryjayy.github.io/posts/Ktlint_%EB%8F%84%EC%9E%85%ED%95%98%EA%B8%B0/" /> <author> <name>{"name"=>"hungryjayy", "link"=>"https://github.com/hungryjayy"}</name> </author> <category term="Study" /> <category term="Kotlin" /> <summary> Ktlint란? : Kotlin의 코드 스타일 검사 및 포맷팅 도구. 팀 내에서 일관된 코드 스타일을 유지하기 위해 사용된다. 공식 Kotlin 코딩 컨벤션을 기반으로 동작 Gradle 플러그인으로 쉽게 통합 가능 .editorconfig를 통해 프로젝트별 규칙 커스터마이징 가능 왜 도입했는가? 일관된 코드 스타일: 팀원들마다 다른 코드 스타일을 통일 가독성 향상 및 코드 리뷰 시 스타일에 대한 논쟁을 줄일 수 있다 자동화된 포맷팅: 수동으로 스타일을 맞출 필요 없이 명령어 하나로 자동 포맷팅 설정 방법 1. build.gradle 설정 Gradle 프로젝트에 ktlint 플러그인을 추가한다. plugins { ... </summary> </entry> <entry><title>Callback 방식의 캐싱 구현으로 AOP의 한계 극복하기</title><link href="https://hungryjayy.github.io/posts/Callback_%EB%B0%A9%EC%8B%9D%EC%9D%98_%EC%BA%90%EC%8B%B1_%EA%B5%AC%ED%98%84%EC%9C%BC%EB%A1%9C_AOP%EC%9D%98_%ED%95%9C%EA%B3%84_%EA%B7%B9%EB%B3%B5%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="Callback 방식의 캐싱 구현으로 AOP의 한계 극복하기" /><published>2025-10-10T00:00:00+09:00</published> <updated>2025-10-24T19:15:42+09:00</updated> <id>https://hungryjayy.github.io/posts/Callback_%EB%B0%A9%EC%8B%9D%EC%9D%98_%EC%BA%90%EC%8B%B1_%EA%B5%AC%ED%98%84%EC%9C%BC%EB%A1%9C_AOP%EC%9D%98_%ED%95%9C%EA%B3%84_%EA%B7%B9%EB%B3%B5%ED%95%98%EA%B8%B0/</id> <content src="https://hungryjayy.github.io/posts/Callback_%EB%B0%A9%EC%8B%9D%EC%9D%98_%EC%BA%90%EC%8B%B1_%EA%B5%AC%ED%98%84%EC%9C%BC%EB%A1%9C_AOP%EC%9D%98_%ED%95%9C%EA%B3%84_%EA%B7%B9%EB%B3%B5%ED%95%98%EA%B8%B0/" /> <author> <name>{"name"=>"hungryjayy", "link"=>"https://github.com/hungryjayy"}</name> </author> <category term="Study" /> <category term="Spring boot" /> <summary> Spring의 @Cacheable 어노테이션은 편리하지만, 같은 클래스 내부에서 메서드를 호출할 때 AOP가 동작하지 않는다는 한계가 있다. 이를 해결하기 위해 callback 방식의 고차함수를 활용한 캐싱 로직을 구현했다. 이 방식은 AOP의 한계를 극복하면서도 캐싱 로직을 재사용 가능하게 만들어준다. @Cacheable의 한계 Spring의 @Cacheable은 AOP 기반으로 동작한다. AOP는 프록시 패턴을 통해 동작하기 때문에, 같은 클래스 내부에서 메서드를 호출할 때는 프록시를 거치지 않아 캐싱이 동작하지 않는다. e.g.) Service 클래스 내부에서 this.getCachedData()를 호출하면 @Cacheable이 적용되... </summary> </entry> <entry><title>Redis cluster 해시태그</title><link href="https://hungryjayy.github.io/posts/Redis_cluster_%ED%95%B4%EC%8B%9C%ED%83%9C%EA%B7%B8/" rel="alternate" type="text/html" title="Redis cluster 해시태그" /><published>2025-09-05T00:00:00+09:00</published> <updated>2025-09-12T18:13:37+09:00</updated> <id>https://hungryjayy.github.io/posts/Redis_cluster_%ED%95%B4%EC%8B%9C%ED%83%9C%EA%B7%B8/</id> <content src="https://hungryjayy.github.io/posts/Redis_cluster_%ED%95%B4%EC%8B%9C%ED%83%9C%EA%B7%B8/" /> <author> <name>{"name"=>"hungryjayy", "link"=>"https://github.com/hungryjayy"}</name> </author> <category term="Study" /> <category term="Redis" /> <summary> : Redis cluster를 사용할 때 n개의 키에 multiGet을 하면, 각각의 키가 저장된 슬롯으로 n번의 get 호출이 가게 된다. 이후, redis 클라이언트에서 이를 조합하는데 성능이 많이 떨어지게 된다. hashTag를 사용하면 같은 해시를 갖는 키들은 하나의 슬롯에 저장되어 한번의 호출만으로 불러오는게 가능하다. Redis Cluster와 해시 태그 Redis Cluster는 데이터를 여러 노드에 분산해서 저장함으로써 높은 성능과 가용성을 제공한다. 데이터는 16,384개의 슬롯에 매핑되고, 각 노드는 이 슬롯의 일부를 담당한다. (예: 3 노드면 약 5천 개씩 담당) 기본적으로 Redis는 키(key)의 이름을 CRC16 해시 함수에 적용해서 어떤 슬롯에 저장할지 결정... </summary> </entry> <entry><title>시작하세요! 도커 / 쿠버네티스 6장 쿠버네티스 시작하기</title><link href="https://hungryjayy.github.io/posts/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94_%EB%8F%84%EC%BB%A4_%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4_6%EC%9E%A5_%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4_%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="시작하세요! 도커 / 쿠버네티스 6장 쿠버네티스 시작하기" /><published>2022-08-12T00:00:00+09:00</published> <updated>2022-08-12T19:44:08+09:00</updated> <id>https://hungryjayy.github.io/posts/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94_%EB%8F%84%EC%BB%A4_%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4_6%EC%9E%A5_%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4_%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/</id> <content src="https://hungryjayy.github.io/posts/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94_%EB%8F%84%EC%BB%A4_%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4_6%EC%9E%A5_%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4_%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/" /> <author> <name>{"name"=>"hungryjayy", "link"=>"https://github.com/hungryjayy"}</name> </author> <category term="Study" /> <category term="Kubernetes" /> <summary> 쿠버네티스란? 도커 컨테이너, 스웜, 컴포즈와 같은 개념을 모두 사용 가능하다. 사실상 표준으로 사용되는 컨테이너 오케스트레이션 도구이다. 클라우드 환경에 적합한 오픈소스를 관리하는 Cloud Native(CNCF - 오픈소스 단체)에 속해있다. containerd, 프로메테우스 등이 CNCF 소속 장점 클러스터링, MSA구조의 컨테이너 배포, 장애 복구 등 운영에 필요한 오케스트레이션 기능을 지원한다. 구글, redhat을 비롯한 많은 오픈소스 진영에서 쿠버네티스에 기여하고 있다. 영속적 볼륨, 스케줄링, 장애 복구, 오토 스케일링, 서비스 발견, ingress 등의 기능들을 개발자가 직접 설정할 수 있다. 다른 클라우드 운영도... </summary> </entry> <entry><title>시작하세요! 도커 / 쿠버네티스 4장 도커 컴포즈</title><link href="https://hungryjayy.github.io/posts/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94_%EB%8F%84%EC%BB%A4_%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4_4%EC%9E%A5_%EB%8F%84%EC%BB%A4_%EC%BB%B4%ED%8F%AC%EC%A6%88/" rel="alternate" type="text/html" title="시작하세요! 도커 / 쿠버네티스 4장 도커 컴포즈" /><published>2022-08-10T00:00:00+09:00</published> <updated>2022-08-12T19:44:08+09:00</updated> <id>https://hungryjayy.github.io/posts/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94_%EB%8F%84%EC%BB%A4_%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4_4%EC%9E%A5_%EB%8F%84%EC%BB%A4_%EC%BB%B4%ED%8F%AC%EC%A6%88/</id> <content src="https://hungryjayy.github.io/posts/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94_%EB%8F%84%EC%BB%A4_%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4_4%EC%9E%A5_%EB%8F%84%EC%BB%A4_%EC%BB%B4%ED%8F%AC%EC%A6%88/" /> <author> <name>{"name"=>"hungryjayy", "link"=>"https://github.com/hungryjayy"}</name> </author> <category term="Study" /> <category term="Docker" /> <summary> : 필요한 컨테이너들의 설정을 하나의 파일로 구성해 한번에 띄우도록 하는 것 특징 도커에 내장되어있지 않아 별도로 설치해야한다. 생산성: 하나의 서비스가 여러개의 컨테이너로 구성되어있을 때 개발 환경을 위해 하나하나 띄우는 것은 생산성을 저하시킨다. 컴포즈를 통해 이러한 생상성 저하를 막을 수 있다. Dockerfile을 run할때 부여했던 옵션값들을 모두 컴포즈 yaml에 작성 가능하다. 추가적인 기능 스케일링: docker-compose scale service=2 와 같은 형태로 스케일링이 가능하다. yaml 파일에 scale을 명시할 수도 있다. depends_on : 컨테이너간 의존관계와 condition을 설정해, 해당 ... </summary> </entry> </feed>
