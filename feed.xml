<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://hungryjayy.github.io/</id><title>hungryjayy</title><subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2025-11-21T15:27:24+09:00</updated> <author> <name>Joowon Son</name> <uri>https://hungryjayy.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://hungryjayy.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://hungryjayy.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2025 Joowon Son </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Singleton Exception 재사용으로 인한 스택 트레이스 문제</title><link href="https://hungryjayy.github.io/posts/Singleton_Exception_%EC%8A%A4%ED%83%9D_%ED%8A%B8%EB%A0%88%EC%9D%B4%EC%8A%A4_%EB%AC%B8%EC%A0%9C/" rel="alternate" type="text/html" title="Singleton Exception 재사용으로 인한 스택 트레이스 문제" /><published>2025-11-14T00:00:00+09:00</published> <updated>2025-11-14T00:00:00+09:00</updated> <id>https://hungryjayy.github.io/posts/Singleton_Exception_%EC%8A%A4%ED%83%9D_%ED%8A%B8%EB%A0%88%EC%9D%B4%EC%8A%A4_%EB%AC%B8%EC%A0%9C/</id> <content src="https://hungryjayy.github.io/posts/Singleton_Exception_%EC%8A%A4%ED%83%9D_%ED%8A%B8%EB%A0%88%EC%9D%B4%EC%8A%A4_%EB%AC%B8%EC%A0%9C/" /> <author> <name>{"name"=>"hungryjayy", "link"=>"https://github.com/hungryjayy"}</name> </author> <category term="Language" /> <category term="Java" /> <summary> 문제 발견 : 운영 중인 서비스의 APM(Application Performance Monitoring) 시스템을 모니터링하던 중, 이상한 현상을 발견했다. 특정 API에서 발생한 Exception의 스택 트레이스가 실제 발생 위치와 전혀 다른 경로를 가리키고 있었다. 더욱 이상한 점은, 모든 Exception들이 동일한 호출 스택을 가지고 있다는 것이었다. 실제 케이스 (예시 코드) 발생 API: /api/users/{id}/activate 실제 발생 위치: UserActivationService.kt:110 APM에 기록된 스택: com.example.service.exception.BusinessException at BusinessExceptio... </summary> </entry> <entry><title>Ktlint 도입하기</title><link href="https://hungryjayy.github.io/posts/Ktlint_%EB%8F%84%EC%9E%85%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="Ktlint 도입하기" /><published>2025-10-24T00:00:00+09:00</published> <updated>2025-10-24T00:00:00+09:00</updated> <id>https://hungryjayy.github.io/posts/Ktlint_%EB%8F%84%EC%9E%85%ED%95%98%EA%B8%B0/</id> <content src="https://hungryjayy.github.io/posts/Ktlint_%EB%8F%84%EC%9E%85%ED%95%98%EA%B8%B0/" /> <author> <name>{"name"=>"hungryjayy", "link"=>"https://github.com/hungryjayy"}</name> </author> <category term="Language" /> <category term="Kotlin" /> <summary> Ktlint란? : Kotlin의 코드 스타일 검사 및 포맷팅 도구. 팀 내에서 일관된 코드 스타일을 유지하기 위해 사용된다. 공식 Kotlin 코딩 컨벤션을 기반으로 동작 Gradle 플러그인으로 쉽게 통합 가능 .editorconfig를 통해 프로젝트별 규칙 커스터마이징 가능 왜 도입했는가? 일관된 코드 스타일: 팀원들마다 다른 코드 스타일을 통일 가독성 향상 및 코드 리뷰 시 스타일에 대한 논쟁을 줄일 수 있다 자동화된 포맷팅: 수동으로 스타일을 맞출 필요 없이 명령어 하나로 자동 포맷팅 설정 방법 1. build.gradle 설정 Gradle 프로젝트에 ktlint 플러그인을 추가한다. plugins { ... </summary> </entry> <entry><title>Callback 방식의 캐싱 구현으로 AOP의 한계 극복하기</title><link href="https://hungryjayy.github.io/posts/Callback_%EB%B0%A9%EC%8B%9D%EC%9D%98_%EC%BA%90%EC%8B%B1_%EA%B5%AC%ED%98%84%EC%9C%BC%EB%A1%9C_AOP%EC%9D%98_%ED%95%9C%EA%B3%84_%EA%B7%B9%EB%B3%B5%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="Callback 방식의 캐싱 구현으로 AOP의 한계 극복하기" /><published>2025-10-10T00:00:00+09:00</published> <updated>2025-10-10T00:00:00+09:00</updated> <id>https://hungryjayy.github.io/posts/Callback_%EB%B0%A9%EC%8B%9D%EC%9D%98_%EC%BA%90%EC%8B%B1_%EA%B5%AC%ED%98%84%EC%9C%BC%EB%A1%9C_AOP%EC%9D%98_%ED%95%9C%EA%B3%84_%EA%B7%B9%EB%B3%B5%ED%95%98%EA%B8%B0/</id> <content src="https://hungryjayy.github.io/posts/Callback_%EB%B0%A9%EC%8B%9D%EC%9D%98_%EC%BA%90%EC%8B%B1_%EA%B5%AC%ED%98%84%EC%9C%BC%EB%A1%9C_AOP%EC%9D%98_%ED%95%9C%EA%B3%84_%EA%B7%B9%EB%B3%B5%ED%95%98%EA%B8%B0/" /> <author> <name>{"name"=>"hungryjayy", "link"=>"https://github.com/hungryjayy"}</name> </author> <category term="Framework" /> <category term="Spring_Boot" /> <summary> Spring의 @Cacheable 어노테이션은 편리하지만, 같은 클래스 내부에서 메서드를 호출할 때 AOP가 동작하지 않는다는 한계가 있다. 이를 해결하기 위해 callback 방식의 고차함수를 활용한 캐싱 로직을 구현했다. 이 방식은 AOP의 한계를 극복하면서도 캐싱 로직을 재사용 가능하게 만들어준다. @Cacheable의 한계 Spring의 @Cacheable은 AOP 기반으로 동작한다. AOP는 프록시 패턴을 통해 동작하기 때문에, 같은 클래스 내부에서 메서드를 호출할 때는 프록시를 거치지 않아 캐싱이 동작하지 않는다. e.g.) Service 클래스 내부에서 this.getCachedData()를 호출하면 @Cacheable이 적용되... </summary> </entry> <entry><title>시작하세요! 도커 / 쿠버네티스 6장 쿠버네티스 시작하기</title><link href="https://hungryjayy.github.io/posts/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94_%EB%8F%84%EC%BB%A4_%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4_6%EC%9E%A5_%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4_%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="시작하세요! 도커 / 쿠버네티스 6장 쿠버네티스 시작하기" /><published>2022-08-12T00:00:00+09:00</published> <updated>2022-08-12T00:00:00+09:00</updated> <id>https://hungryjayy.github.io/posts/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94_%EB%8F%84%EC%BB%A4_%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4_6%EC%9E%A5_%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4_%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/</id> <content src="https://hungryjayy.github.io/posts/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94_%EB%8F%84%EC%BB%A4_%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4_6%EC%9E%A5_%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4_%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/" /> <author> <name>{"name"=>"hungryjayy", "link"=>"https://github.com/hungryjayy"}</name> </author> <category term="DevOps" /> <category term="Kubernetes" /> <summary> 쿠버네티스란? 도커 컨테이너, 스웜, 컴포즈와 같은 개념을 모두 사용 가능하다. 사실상 표준으로 사용되는 컨테이너 오케스트레이션 도구이다. 클라우드 환경에 적합한 오픈소스를 관리하는 Cloud Native(CNCF - 오픈소스 단체)에 속해있다. containerd, 프로메테우스 등이 CNCF 소속 장점 클러스터링, MSA구조의 컨테이너 배포, 장애 복구 등 운영에 필요한 오케스트레이션 기능을 지원한다. 구글, redhat을 비롯한 많은 오픈소스 진영에서 쿠버네티스에 기여하고 있다. 영속적 볼륨, 스케줄링, 장애 복구, 오토 스케일링, 서비스 발견, ingress 등의 기능들을 개발자가 직접 설정할 수 있다. 다른 클라우드 운영도... </summary> </entry> <entry><title>시작하세요! 도커 / 쿠버네티스 4장 도커 컴포즈</title><link href="https://hungryjayy.github.io/posts/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94_%EB%8F%84%EC%BB%A4_%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4_4%EC%9E%A5_%EB%8F%84%EC%BB%A4_%EC%BB%B4%ED%8F%AC%EC%A6%88/" rel="alternate" type="text/html" title="시작하세요! 도커 / 쿠버네티스 4장 도커 컴포즈" /><published>2022-08-10T00:00:00+09:00</published> <updated>2022-08-10T00:00:00+09:00</updated> <id>https://hungryjayy.github.io/posts/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94_%EB%8F%84%EC%BB%A4_%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4_4%EC%9E%A5_%EB%8F%84%EC%BB%A4_%EC%BB%B4%ED%8F%AC%EC%A6%88/</id> <content src="https://hungryjayy.github.io/posts/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94_%EB%8F%84%EC%BB%A4_%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4_4%EC%9E%A5_%EB%8F%84%EC%BB%A4_%EC%BB%B4%ED%8F%AC%EC%A6%88/" /> <author> <name>{"name"=>"hungryjayy", "link"=>"https://github.com/hungryjayy"}</name> </author> <category term="DevOps" /> <category term="Docker" /> <summary> : 필요한 컨테이너들의 설정을 하나의 파일로 구성해 한번에 띄우도록 하는 것 특징 도커에 내장되어있지 않아 별도로 설치해야한다. 생산성: 하나의 서비스가 여러개의 컨테이너로 구성되어있을 때 개발 환경을 위해 하나하나 띄우는 것은 생산성을 저하시킨다. 컴포즈를 통해 이러한 생상성 저하를 막을 수 있다. Dockerfile을 run할때 부여했던 옵션값들을 모두 컴포즈 yaml에 작성 가능하다. 추가적인 기능 스케일링: docker-compose scale service=2 와 같은 형태로 스케일링이 가능하다. yaml 파일에 scale을 명시할 수도 있다. depends_on : 컨테이너간 의존관계와 condition을 설정해, 해당 ... </summary> </entry> </feed>
