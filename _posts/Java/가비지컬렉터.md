# JVM의 가비지 컬렉터

: 유효하지 않은(더 이상 불필요한) 메모리를 JVM이 정리해주는 것



<img src="https://github.com/WeareSoft/tech-interview/raw/master/contents/images/JVMHeap.png" alt="jvmheap" style="zoom: 80%;" />

* 이러한 GC는 자바(JVM)의 GC. C++ / C언어에서는 `free()`를 통해 직접 할당을 해제해줘야 함.
* Permanent는 Heap 영역이 아님. java 8 이후로 Metaspace 영역으로 대체되었다고 함



## GC 설계의 바탕

1. 대부분의 객체는 금방 unreachable 상태가 된다.
   * 메서드 종료 시 더이상 사용하지 않음
2. Old 객체가 Young 객체를 참조하는 일은 드물다.
   * 1번과 비슷한 맥락.(Spring과 같이 framework 레벨의 Bean 예외)



## Minor GC, Major GC

* Young 영역의 각 하위 영역이 가득 차면 Minor GC 발생해 더이상 참조되지 않는 객체 제거
* Old 영역이 가득차면 Major GC(Full GC) 발생해 더이상 참조되지 않는 객체 제거



#### Stop the world 

* GC를 수행하는 데몬 스레드 외에 모든 스레드 작업 멈추는 상태. GC 완료 후 다시 스레드 들이 실행 상태 됨
  * 이를 최소화하기 위해 GC 튜닝



#### Mark and Sweap

* GC는 객체를 돌면서 각각이 어떤 객체를 참조하고 있는지 탐색.
* Mark: 사용되는 메모리 식별하고 마크
* Sweap: Mark 되지 않은 객체 메모리에서 제거



### 동작 과정

1. 객체 생성 시 YG의 Eden으로
2. Eden영역이 꽉차 Minor GC 발생하고, 살아남으면(참조 되고 있으면) Survivor 1로 이동
3. Survivor 1에서 Minor GC때 또 살아남으면 Survivor 2로 이동
4. Survivor 2에서 Minor GC때 살아남으면 Survivor 1로 이동(1 <--> 2 반복)
5. age bit(**Minor GC에서 살아남은 횟수**)가 지정해놓은 `MaxTenuringThreshold` 를 넘게 되면, Old 영역으로
6. Old 영역의 객체는 MajorGC때 참조 여부에 따라 살아남거나 제거



## GC 종류



### G1(Garbage first) GC

![img](https://blog.kakaocdn.net/dn/dHxPiT/btqU0xWGaDI/wriFcFKPHND5pTAsyn47X1/img.png) 

* Java 9 이상 default GC. (7~8은 Parallel GC)
* Stop the world 최소화 목적
* **Region 개념 도입**
  * 힙을 균등하게 region으로 나누고, 가비지가 많은 region에 우선적으로 GC
  * Minor - Eden에 많다 싶으면 해당 지역 GC 하고, 살아남은 객체 다른 영역 이동. 복제되는 지역이 Available / Unused면 해당 영역은 Survivor이 되고, Eden이었던 곳은 Available/Unused 된다.
  * Major - GC가 많은 지역을 조합해 해당 지역에 GC 수행
* 좋은 경우
  * Java heap 반 이상이 라이브 데이터일 때
  * GC가 너무 오래 걸릴 때



### Serial GC

* Mark Sweap 이용
* 서버 CPU 코어 1개일 때 만들어짐. 따라서, 모든 GC를 처리하기 위해 1개의 스레드 사용



### Parallel GC

* 시리얼과 비슷하지만, 여러개의 스레드를 통해 패러랠하게 GC 수행



### CMS(Concurrent Mark Sweap) GC

* 패러랠과 마찬가지로 여러개의 스레드 사용
* Stop-the-world 발생하는 sweap 시간 최소화
  1. initial mark - root set에서 가까운 객체 중 살아남을 객체를 탐색 (stop the world 짧게 발생)
  2. concurrent mark - GC대상으로 판별한 것을 따라가며 GC대상인지 추가 확인 (stop the world X)
  3. remark - 추가 확인. (stop the world 발생, 멀티 스레드로 검증해 시간 줄임)
  4. concurrent sweap - GC 대상 멀티스레드로 메모리에서 제거 (stop the world X)



#### Reference)

#### https://velog.io/@hygoogi/%EC%9E%90%EB%B0%94-GC%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C

#### https://github.com/WeareSoft/tech-interview/blob/master/contents/java.md

#### https://deveric.tistory.com/64

#### https://mangkyu.tistory.com/119