---

layout: post

title: HTTP 완벽가이드 5장 - 웹 서버가 하는 일

author: 
  name: hungryjayy
  link: https://github.com/hungryjayy

description: null

tags: [http]

featuredImage: 

img: 

categories: [HTTP]

date: '2021-08-01'

extensions:

  preset: gfm

---

<br>

* 웹 서버는 목적에 따라 다양하지만, 기본적으로 **리소스에 대한 HTTP 요청을 받아 콘텐츠를 클라이언트에게 돌려**주는 일을한다.
  * 간단한 일을 처리하는 작은 임베디드 서버(프린터, 가전기기, IoT 등)을 생각해보자
* 커넥션을 맺고, 요청을 받고, 처리(해석)하고, 리소스에 접근하고, 응답을 만들고 보낸다.

<br>

## 1. 커넥션 수락

: 커넥션을 지속하고 있지 않는 이상 새로운 커넥션을 만든다.

* 유닉스 환경에서 TCP 커넥션은 소켓으로 표현되며, 소켓을 통해 IP를 추출해낸다(`getpeername`)
* 대부분은 역방향 DNS로 알아낸 IP 주소를 **클라이언트의 호스트 명**으로 변환.
* 몇몇은 ident 프로토콜을 지원(어떤 사용자 이름이 HTTP 커넥션을 초기화했는지 알 수 있도록)

<br>

## 2. 요청 메시지 수신

: 요청메시지를 CRLF로 구분해 요청줄, 헤더, 메시지로 파싱한다. - 몇몇 웹 서버는 그것을 key-value 자료구조에 저장

* 웹 서버는 **항상 새 요청을 주시하고 있다**고 보면 된다.
* 웹 서버에 따라 요청을 처리하는 방식이 달라진다.

<br>

### 요청 메시지 처리에 따른 방식

<img src="https://hungryjayy.github.io/assets/img/Http/request_processes.md.png" alt="request_processes.md" style="zoom: 45%;" /> 

*request 처리방식 설명에 이만한 그림은 없는 것 같다.*

<br>

1. **단일 스레드 I/O 아키텍처**: 한번에 하나씩 요청 처리. 트랜젝션 완료 시 다음 커넥션 처리(간단한 서버에서만 사용)
2. **멀티 스레드 I/O 아키텍처**: 커넥션을 받는 스레드를 늘릴 수 있다. 동적으로도 가능하고, 미리 할당해놓을 수 있다. 수만 건을 처리하는데 스레드를 다 만들어놓으면 오히려 시스템 리소스를 과소비하게 된다. 따라서 **제한**을 건다.
   * **Apache**에서 사용하는 방식이 이 방식인 것 같다.
3. **다중 I/O 아키텍처**: 한 커넥션에 대해서 처리하다보면 Blocked 되는 테스크에 대해 유휴시간이 발생할텐데, 이 유휴시간동안 다른 Task를 처리한다.
   * 한 커넥션에 대한 처리가 완료되면, 커넥션은 **다음번의 state 변경을 기다리기 위해 커넥션 목록**으로 들어가고, 스레드는 수행할 수 있는 커넥션을 빼와서 수행한다.
   * **NginX**에서 사용하는 방식. **비동기적 처리**
4. **다중, 멀티스레드 I/O 아키텍처**: 동작만 잘 되도록 구성한다면 가장 이상적인 방법 일 것으로 보인다.

<br>

## 3. 요청 처리

: 웹서버에서 처리할 수 있는 적절한 처리를 수행한다. 단, **WAS 개입**이나 다른 **동적 컨텐츠**에 대해서는 당연히 **리소스** 접근이 필요.

<br>

## 4. 리소스 접근

: **정적 리소스(HTML, CSS, JPEG)에 대한 것은 웹 서버** 에서 처리, 리소스는 주로 동적 컨텐츠가 필요할 떄

<br>

#### docroot

:요청 URI를 파일 시스템 내의 파일 이름으로 사용하는 방식

* e.g) `/aaa/bbb.gif` 요청이 들어오고 문서 루트가 `/usr/local` 라면 `/usr/local/aaa/bbb.gif` 파일을 반환
* **가상 호스팅 docroot**: 한 **웹 서버가 여러 웹 사이트를 호스팅**하고 URI나 Host 헤더로부터 얻은 IP주소나 호스트 명을 통해 문서 루트를 식별하고 적절한 콘텐츠를 전달해 주는 것
* 사용자 홈 디렉터리 docroots : 사용자가 자신의 로컬에서 자신의 웹 사이트를 만들도록 하는 것

<br>

#### 디렉터리 목록 요청: 색인 파일(index.html) 반환

<br>

#### 동적 콘텐츠 리소스 맵핑

: 동적 리소스에 맵핑.

* 애플리케이션 서버는 백엔드 애플리케이션과 연결되는 것

* e.g) 아파치는 URI의 경로명이 바이너리의 위치로 맵핑되도록 기능을 제공한다.

  `ScriptAlias /cgi-bin/ /usr/local/etc/httpd/cgi-programs/`

<br>

## 5. 응답 만들기

* 웹 서버는 응답 메시지를 만든다. (상태 코드, 헤더, 본문)
* 응답 본문(엔티티): `Content-Type`(MIME), `Content-Length`, 본문내용
* MIME type 결정
  * 매치 타이핑: 웹 서버가 직접 파일 내용을 검사 (표준 확장자 없는 경우)
  * 유형 명시: 항상 어떤 type을 갖도록 웹 서버에 명시
  * 유형 협상: 여러 종류에 속하도록 설정. 사용자와 협상을 통해 가장 좋은 형식으로 정함
* 리다이렉션 : Location 응답 헤더에 새로운 위치 URI를 포함시킴
  * 영구히 리소스가 옮겨진 경우(301 Moved Permanently)
  * 임시로 리소스 옮겨진 경우
  * URL 증강: **뚱뚱한 URL** 세션 유지 용도로 **URL 뒤에 유저의 상태 정보를 붙여서** 리다이렉션 -> 사용자는 해당 상태(세션)를 포함해 재요청

<Br>

## 6. 응답 보내기

: 커넥션 너머로 데이터를 보낼 때에 받을때와 비슷한 이슈에 직면. 커넥션 상태를 추적해야 하며, 지속 커넥션이라면 `Content-Length`를 고려하는 등

<br><br>

#### Reference)

HTTP 완벽 가이드
