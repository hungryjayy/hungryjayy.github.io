# 자바의정석 - 14장 람다식

: 메서드를 하나의 식(expression)으로 표현한 것. 그래서 변수처럼 사용이 가능해진다.

* JEDK1.8에 추가된 문법.
* 자바에 함수형 패러다임을 갖도록 한 문법.
* 자바에서는 기본적으로 메서드를 만들려면 **클래스**를 만들고, 객체도 생성해야하는데, 이 모든 과정을 생략 가능하게 해준다.

<br>

## 함수형 인터페이스

: 람다식을 변수로 받을 수 있는 **참조변수**

* `@FunctionalInterface`를 사용해 함수형 인터페이스임을 알린다.

* **단 하나의 abstract 메소드**만을 가질 수 있다. 그래야 **람다식과 인터페이스의 메서드가 1:1**로 연결될 수 있기 때문이다. (default, static 제외)

  * `Comparator` 내부를 확인해보면 디폴트 메소드를 제외하고는 `compare` 라는 메서드 하나 있다. (`equals()` 는 `Object` 클래스로부터 받은 것)

  ```java
  @FunctionalInterface
  public interface FooInterface {
      int plus(int a, int b);
  }
  
  // --- 아래와같이 사용
  
  FooInterface f = (x, y) -> x + y; // A
  int result = f.plus(5, 3);
  
  // B
  FooInterface f = new FooInterface() {
      @Override
  		public int plus(int a, int b) {
      		return 0;
    	}
  };
  ```

  * A와 B는 같다. 함수형 인터페이스를 구현하는 `public int~~` 부분을 람다식으로 줄여준 버전이 A

<br>

## java.util.function

* `java.util.function` 패키지에 **일반적으로 쓰이는 형식의 메서드가 구현되어있으니**, 매번 새롭게 정의하지 말고 이 패키지의 인터페이스를 활용할 것이 권장된다.
* 이 패키지에 존재하는 함수형 Interface들은 컬렉션 프레임워크에서 몇 메서드들의 매개변수로 받고있다.

<br>

#### 합성

* 수학에서 f(g(x)) 하는 것처럼, 함수형 인터페이스를 합성할 수 있다.

  ```java
  Function<String, Integer> f = x -> 5;
  Function<Integer, String> g = x -> x.toString();
  Function<String, String> h = f.andThen(g); // g.compose(f)
  
  Predicate<Integer> p = i -> i > 100;
  Predicate<Integer> q = i -> i < 200;
  Predicate<Integer> r = i -> i % 2 == 0;
  
  Predicate<Integer> all = p.and(q.or(r));
  ```

<br>

### 메서드 참조

: `String::equals` 과 같은 더 간결한 문법도 람다식에 해당한다.

* '클래스이름::메서드이름' 혹은 '참조변수::메서드이름'의 방식으로 가능하다

  ```java
  () -> new myClass();
  (a, b) -> new myClass(a, b);
  
  x -> new int[x];
  
  // 위의 expression이 아래로 가능
  myClass::new;
  
  int[]::new;
  ```

<br><br>

#### Reference) 자바의 정석 3판

