# 힙 정렬(Heap sort)

: 자료구조 힙(최대 힙, 최소 힙)을 이용한 정렬 방법

* 최대 힙, 최소 힙으로 내림차순, 오름차순 정렬을 할 수 있다.
* `O(n log n)` 의 시간복잡도를 가져, 가장 빠른 정렬 방법 중 하나이다.
* 힙은 `완전 이진 트리` 구조를 가진다.
* 힙의 특성상 **가장 앞의 값**이 항상 많이 쓰인다.
  * 따라서, 가장 유용할 때는 **가장 큰 몇개**만 필요할 때



## 힙의 삽입



### 과정

1. 힙에 새로운 요소가 들어오면, 힙의 leaf노드에 삽입한다.
2. 새 노드가 우선순위 규칙에 맞는지 확인한다. 부모 노드와 자리를 교체한다.
3. 2번의 과정을 통해 우선순위가 맞게 되면 끝. 더이상 교환하지 않는다.



### 코드

```c++
// 배열로 구현
void insertMaxHeap(int heap[], int target) {
  int i = sizeof(heap) - 1;
  heap[i] = target;
  
  while(heap[i] > heap[i / 2]) {
    int tmp = heap[i];
    heap[i] = heap[i / 2];
    heap[i / 2] = tmp;
  }
}
```



## 힙의 삭제



### 과정

1. 항상 Root노드가 삭제.(최대 힙은 최대 값, 최소 힙은 최소 값)
2. 삭제된 Root노드에 Leaf 노드를 가져온다.
3. Root가 된 Leaf값을 자식과 비교해, 자식 중 **우선순위에 더 가까운 것**과 swap
   * 배열로 생각해보면 가장 왼쪽자식이 항상 가까움



### 코드

```c++
// 배열로 구현
void deleteMaxHeap(int heap[]) {
  heap[sizeof(heap) - 1] = 0;
  heap[0] = heap[sizeof(heap) - 1];
  int child = 1;
 	int me = 0;
    
  while(child < sizeof(heap) && heap[child] > heap[me]) {
    int tmp = heap[child];
    heap[child] = heap[me];
    heap[me] = tmp;
    
    me = child;
    child *= 2;
  }
}
```

