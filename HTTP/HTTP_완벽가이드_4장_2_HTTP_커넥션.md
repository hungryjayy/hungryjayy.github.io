# HTTP 완벽가이드 4장 - 2. HTTP 커넥션

<br>

### Connection 헤더란?

* **헤더 보호하기** : 한 Connection 작업에서만 사용되어야 하는 **토큰 값**들을 쉼표로 구분해 갖고 있는다.

  * 다른 커넥션(다른 홉)에 전달되는 것 방지

    ```http
    HTTP/1.1 200 OK
    Cache-control: max-age=3600
    Connection: meter, close, bill-my-credit-card
    ```

    * 위의 메시지에서 `Connection:` 부분에 명시한 것
  
* **Hop-by-Hop**: 두 홉(노드) 사이에서만 전달되고 그 이후엔 없어져야 한다.(클라 - 프락시 or 프락시 - 서버 등)

<br>

## 병렬 커넥션

: HTTP 클라이언트가 여러 개의 TCP 커넥션을 맺어 HTTP 트랜잭션을 병렬로 처리할 수 있게 한다.

* 클라이언트 입장에서의 **객체당 한 서버**와 커넥션을 맺어 **각 커넥션의 지연시간을 겹치게 해** 처리 속도를 빠르게 하는 것

#### 항상 빠르지는 않다.

1. 대역폭이 좁으면 각 객체를 전송하는게 느리기 때문에 성능상 장점이 없다.
2. 실제로 연결하는 **병렬 커넥션 수에는 제한**이 있다. (커넥션을 늘릴 수록 성능 문제) 
   * 한 사용자 당 100개의 커넥션을 허용하고 100명의 사용자가 사용하면 서버는 10000개의 커넥션을 맺어야 하는데, 이 것은 **큰 부하**가 될 수 있다.
   * 따라서, **최신 브라우저는 대부분 6~8**개 라고 함
3. 연결을 맺고 끊음을 반복하다보니 **TCP의 느린 시작**을 피할 수 없다.

<br>

## 지속 커넥션

: HTTP 트랜잭션이 처리된 이후에도 커넥션을 끊지 않고 재사용하는 것

* **사이트 지역성**(site locality): 서버에 HTTP 요청을 하기 시작한 애플리케이션은 웹 페이지 내의 이미지 등을 가져오기 위해 **그 서버에 또 요청을 할 것**
* **커넥션을 맺기위한 준비작업**을 줄일 수 있고, **TCP 느린 시작**으로 인한 지연을 피할 수 있다.
  * **튜닝된 커넥션** : 느린시작에서 수차례 성공해서 다수의 패킷을 전송할 권한을 얻은 상태
* **HTTP/1.0의 Keep-Alive**, **HTTP/1.1의 지속 커넥션**
* 지속적으로 커넥션을 유지하는 상황이더라도, 양 측에선 언제건 끊을 수 있긴 하다.

<br>

### HTTP/1.0의 Keep-alive 커넥션

* TCP 핸드셰이크와 느린시작으로 인한 지연을 줄인다.
* Keep-alive가 HTTP/1.1에서 사용하지 않도록 되어 빠졌지만, 많은 브라우저에서 **여전히 Keep-alive를 사용**하기 때문에 개발자는 keep-alive가 가능하도록 개발해야 한다.
* `Connection:Keep-alive` 헤더
  * **요청**에 `Connection:Keep-Alive` 헤더 : "이 방식으로 통신하고 싶다" 의미
  * **응답**에 `Connection:Keep-Alive` 헤더 : "이 방식을 지원할 것"(없다면 연결 끊을 것임을 의미)
  * HTTP/1.0을 따르는 기기로부터 받는 모든 Connection 헤더 필드(`Connection: Keep-Alive`와 같은)는 무시되어야 한다.
    * **멍청한 프락시**: **오래된 프락시**로 전달해서 **Hang** 걸릴 수 있기 때문
  * 이 방식을 사용하려면 정확한 `Content-Length` 값이 있어야 한다. 기존 메시지 끝과 새로운 메시지 시작점을 정확히 알수 어렵기 떄문

<br>

### Keep-alive와 멍청한 프락시(Dumb Proxy)

* 오래된 프락시들은 `Connection:Kepp-Alive` 헤더를 해석하지 못하고 **그대로 전달한다.**

* **`Connection` 헤더는 기본적으로 홉별(Hop-by-Hop) 헤더이기 때문에 한개의 전송 링크에만 적용되며 다음 서버로 전송되면 안된다.**

  <img src="./images/dump_proxy.png" alt="dump_proxy" style="zoom: 25%;" /> 

  * a에서의 `Connection:Keep-Alive` 는 b까지 전파되지 않아야 하는데, 멍청한 프락시 문제로 서버에선 proxy가 커넥션을 유지하자고 요청하는 것으로 잘못 판단하게 된다.
  * **프락시는 서버가 커넥션을 끊기를 기다리지만** 서버는 프락시가 Keep-alive를 요청한 것으로 알기때문에 끊지 않는다.
  * 클라이언트가 유지하고 있는 커넥션으로 요청을 보내면 **같은 커넥션 상 다른 요청이 오는 경우를 예상하지 못하기 때문에 무시**해버린다.

* **해결방안 1** : Proxy는`Connection:Keep_Alive` 헤더를 전달하면 안되고, 당연히 `Keep-Alive: ~~ ` 와 같은 `Keep-Alive` 헤더도 전달하면 안된다.

  * 같은 이유로, **Proxy는 다른 홉별(Hop by HOp) 헤더를 전달 혹은 캐싱하면 안된다.**

* **해결방안 2**: 프락시에 커넥션 관련 메시지를 보낼 때는`Proxy-Connection` 이라는 확장 헤더를 사용

  * 오래된 프락시는 이 것을 똑같이 **무조건 전달**해도, **서버에선 뭔지 모르니** 괜찮다.
  * 영리한 프락시는 이 것을 `Connection` 헤더로 바꾸고 요청한 의도대로 동작할 것
  * 그러나, 멍청한 프락시가 중간에 하나라도 끼어있다면 다시 문제가 발생한다.

* 프락시의 경우 **보이지 않는 경우**가 많기 때문에 지속 커넥션을 명확히 구현하는 것이 중요하다.

<br>

### HTTP/1.1의 지속 커넥션

* 디폴트로 활성화 되어있고, 커넥션을 끊으려면 `Connection: close` 헤더를 명시하는 방식으로 사용
* 마찬가지로 정확한 `Content-Length` 필요
* HTTP/1.1 프락시는 클라이언트, 서버 양측 별도의 지속 커넥션을 맺고 관리해야한다.
* HTTP/1.1 애플리케이션은 중간에 끊어지는 커넥션을 복구할 수 있어야 한다. 이 때 클라이언트는 언제든 재요청 할 준비를 해야 한다.
* 클라이언트는 과부하 방지를 위해 넉넉잡아 두개의 지속 커넥션만 유지해야한다.

<br><br>

<br><br>



<br><br>

#### Reference) HTTP 완벽가이드
